using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Baml.Net.SourceGenerator.Metadata;

namespace Baml.Net.SourceGenerator
{
    internal class BamlCodeGenerator
    {
        private readonly bool _enableLogging;
        private readonly string _rootNamespace;
        private const string IndentUnit = "    ";

        public BamlCodeGenerator(bool enableLogging, string rootNamespace)
        {
            _enableLogging = enableLogging;
            _rootNamespace = !string.IsNullOrWhiteSpace(rootNamespace) ? rootNamespace : "BamlClient";
        }

        public string GenerateCode(List<AdditionalText> additionalFiles)
        {
            try
            {
                // Find the metadata file generated by MSBuild task
                var metadataFile = additionalFiles.FirstOrDefault(f =>
                    f.Path.EndsWith("baml-metadata.json", StringComparison.OrdinalIgnoreCase));

                if (metadataFile == null)
                {
                    // No metadata file found - MSBuild task didn't run or no BAML files
                    return string.Empty;
                }

                // Read metadata content
                var metadataJson = metadataFile.GetText()?.ToString();
                if (string.IsNullOrEmpty(metadataJson))
                    return "// Metadata file is empty";

                // Parse metadata
                var parser = new MetadataParser();
                var metadata = parser.Parse(metadataJson);

                // Generate code
                return GenerateClientCode(metadata);
            }
            catch (Exception ex)
            {
                // Return commented error for debugging
                return $"// Error generating BAML client: {ex.Message}\n// {ex.StackTrace}";
            }
        }


        private string GenerateClientCode(BamlMetadata metadata)
        {
            var sb = new StringBuilder();

            // File header
            sb.AppendLine("// <auto-generated>");
            sb.AppendLine("//     This code was generated by BAML.NET Source Generator.");
            sb.AppendLine("//     Changes to this file may cause incorrect behavior and will be lost if");
            sb.AppendLine("//     the code is regenerated.");
            sb.AppendLine("// </auto-generated>");
            sb.AppendLine();

            // Nullable enable
            sb.AppendLine("#nullable enable");
            sb.AppendLine();

            // Using statements
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine("using System.Threading;");
            sb.AppendLine("using System.Threading.Tasks;");
            sb.AppendLine("using System.Text.Json.Serialization;");
            sb.AppendLine("using Baml.Net.Core;");
            if (_enableLogging)
            {
                sb.AppendLine("using Microsoft.Extensions.Logging;");
            }
            sb.AppendLine();

            // Namespace - use the project's root namespace
            sb.AppendLine($"namespace {_rootNamespace}");
            sb.AppendLine("{");

            // Generate types
            foreach (var type in metadata.Types)
            {
                GenerateType(sb, type, IndentUnit);
                sb.AppendLine();
            }

            // Generate client class
            GenerateClientClass(sb, metadata, IndentUnit);

            sb.AppendLine("}");

            return sb.ToString();
        }

        private void GenerateType(StringBuilder sb, TypeDefinition type, string indent)
        {
            if (type.Kind == "Enum")
            {
                GenerateEnum(sb, type, indent);
            }
            else if (type.Kind == "Record" || type.Kind == "Class")
            {
                GenerateClass(sb, type, indent);
            }
        }

        private void GenerateEnum(StringBuilder sb, TypeDefinition type, string indent)
        {
            sb.AppendLine($"{indent}public enum {type.Name}");
            sb.AppendLine($"{indent}{{");

            if (type.Values != null)
            {
                foreach (var value in type.Values)
                {
                    sb.AppendLine($"{indent}{IndentUnit}{value.Name},");
                }
            }

            sb.AppendLine($"{indent}}}");
        }

        private void GenerateClass(StringBuilder sb, TypeDefinition type, string indent)
        {
            var keyword = type.Kind == "Record" ? "record" : "class";
            sb.AppendLine($"{indent}public {keyword} {type.Name}");
            sb.AppendLine($"{indent}{{");

            if (type.Properties != null)
            {
                foreach (var prop in type.Properties)
                {
                    var nullableSuffix = prop.Nullable ? "?" : "";
                    sb.AppendLine($"{indent}{IndentUnit}[JsonPropertyName(\"{ToCamelCase(prop.Name)}\")]");
                    sb.AppendLine($"{indent}{IndentUnit}public {prop.Type}{nullableSuffix} {prop.Name} {{ get; set; }}");
                    sb.AppendLine();
                }
            }

            sb.AppendLine($"{indent}}}");
        }

        private void GenerateClientClass(StringBuilder sb, BamlMetadata metadata, string indent)
        {
            sb.AppendLine($"{indent}public partial class BamlClient");
            sb.AppendLine($"{indent}{{");

            // Fields
            sb.AppendLine($"{indent}{IndentUnit}private readonly BamlRuntimeAsync _runtime;");
            if (_enableLogging)
            {
                sb.AppendLine($"{indent}{IndentUnit}private readonly ILogger<BamlClient>? _logger;");
            }
            sb.AppendLine();

            // Constructor
            sb.Append($"{indent}{IndentUnit}public BamlClient(BamlRuntimeAsync runtime");
            if (_enableLogging)
            {
                sb.Append(", ILogger<BamlClient>? logger = null");
            }
            sb.AppendLine(")");
            sb.AppendLine($"{indent}{IndentUnit}{{");
            sb.AppendLine($"{indent}{IndentUnit}{IndentUnit}_runtime = runtime ?? throw new ArgumentNullException(nameof(runtime));");
            if (_enableLogging)
            {
                sb.AppendLine($"{indent}{IndentUnit}{IndentUnit}_logger = logger;");
            }
            sb.AppendLine($"{indent}{IndentUnit}}}");
            sb.AppendLine();

            // Generate methods for each function
            foreach (var function in metadata.Functions)
            {
                GenerateMethod(sb, function, indent + IndentUnit);
                sb.AppendLine();
            }

            sb.AppendLine($"{indent}}}");
        }

        private void GenerateMethod(StringBuilder sb, FunctionDefinition function, string indent)
        {
            // Method signature
            var returnType = function.ReturnNullable
                ? $"Task<{function.ReturnType}?>"
                : $"Task<{function.ReturnType}>";

            sb.Append($"{indent}public async {returnType} {function.Name}Async(");

            // Parameters
            var parameters = new List<string>();
            foreach (var param in function.Parameters)
            {
                var nullableSuffix = param.Nullable ? "?" : "";
                parameters.Add($"{param.Type}{nullableSuffix} {param.Name}");
            }
            parameters.Add("CancellationToken cancellationToken = default");
            sb.Append(string.Join(", ", parameters));

            sb.AppendLine(")");
            sb.AppendLine($"{indent}{{");

            // Method body
            var bodyIndent = indent + IndentUnit;

            // Logging - method entry
            if (_enableLogging)
            {
                sb.AppendLine($"{bodyIndent}_logger?.LogDebug(\"Calling BAML function {{Function}} with parameters {{Parameters}}\",");
                sb.AppendLine($"{bodyIndent}{IndentUnit}\"{function.Name}\",");
                sb.Append($"{bodyIndent}{IndentUnit}new {{ ");
                sb.Append(string.Join(", ", function.Parameters.Select(p => $"{p.Name}")));
                sb.AppendLine(" });");
                sb.AppendLine();
            }

            // Prepare arguments
            if (function.Parameters.Any())
            {
                sb.AppendLine($"{bodyIndent}var args = new Dictionary<string, object?>");
                sb.AppendLine($"{bodyIndent}{{");
                foreach (var param in function.Parameters)
                {
                    sb.AppendLine($"{bodyIndent}{IndentUnit}[\"{param.Name}\"] = {param.Name},");
                }
                sb.AppendLine($"{bodyIndent}}};");
            }
            else
            {
                sb.AppendLine($"{bodyIndent}var args = new Dictionary<string, object?>();");
            }
            sb.AppendLine();

            // Call runtime - following the pattern of storing result in variable
            sb.AppendLine($"{bodyIndent}// Call the BAML runtime - store result for debugging");
            sb.AppendLine($"{bodyIndent}var result = await _runtime.CallFunctionAsync<{function.ReturnType}>(");
            sb.AppendLine($"{bodyIndent}{IndentUnit}\"{function.Name}\",");
            sb.AppendLine($"{bodyIndent}{IndentUnit}args,");
            sb.AppendLine($"{bodyIndent}{IndentUnit}null,");
            sb.AppendLine($"{bodyIndent}{IndentUnit}cancellationToken)");
            sb.AppendLine($"{bodyIndent}{IndentUnit}.ConfigureAwait(false);");
            sb.AppendLine();

            // Logging - method exit
            if (_enableLogging)
            {
                sb.AppendLine($"{bodyIndent}_logger?.LogDebug(\"BAML function {{Function}} completed successfully\",");
                sb.AppendLine($"{bodyIndent}{IndentUnit}\"{function.Name}\");");
                sb.AppendLine();
            }

            // Return
            sb.AppendLine($"{bodyIndent}return result;");

            sb.AppendLine($"{indent}}}");
        }

        private string ToCamelCase(string input)
        {
            if (string.IsNullOrEmpty(input))
                return input;

            return char.ToLowerInvariant(input[0]) + input.Substring(1);
        }
    }
}
